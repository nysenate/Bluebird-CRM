<?php

define('BATCHSIZE', 250);
define('BATCHSIZETAG', 5000);
define('VARSTATS', false);

require_once(dirname(__FILE__) . '/nyss_lib.php');

//define menu path
function nyss_io_menu()
{
  $items = [];

  $items['importdata'] = [
    'title' => t('Import Data'),
    'page callback' => 'nyss_ioimportdata_page',
    'access arguments' => ['import print production'],
    'type' => MENU_SUGGESTED_ITEM,
  ];

  return $items;
} // nyss_io_menu()


//define page
function nyss_ioimportdata_page()
{
  return drupal_get_form('nyss_ioimport_form');
} // nyss_ioimportdata_page()


//define form
function nyss_ioimport_form()
{
  civicrm_initialize();
  require_once 'CRM/Core/Config.php';
  require_once 'CRM/Core/DAO.php';

  $config = CRM_Core_Config::singleton();

  $form = [];

  //$form['#attributes'] = array('enctype' => "multipart/form-data");

  //Import and Main Processing
  $form['processing'] = [
    '#type' => 'fieldset',
    '#title' => t('Import Source and Processing Options'),
  ];

  $form['processing']['csv'] = [
    '#type' => 'file',
    '#title' => t('Upload a file'),
    '#size' => 40,
  ];

  $form['processing']['servercsv'] = [
    '#type' => 'textfield',
    '#title' => t('OR specify a filename on the server in the \'/data/importData\' dir'),
    '#size' => 40,
  ];

  $form['processing']['runnum'] = [
    '#type' => 'select',
    '#title' => t('How many records to process in dry run mode (should be set to ALL for data import)'),
    '#options' =>
    [
      '10'   => t('10'),
      '100'  => t('100'),
      '500'  => t('500'),
      '1000' => t('1000'),
      'All'  => t('All'),
    ],
    '#default_value' => '10',
  ];

  $form['processing']['dryrun'] = [
    '#type' => 'checkbox',
    '#title' => t('Dry Run (parses data but does not alter the instance)'),
    '#default_value' => 1,
  ];

  $form['processing']['sendemail'] = [
    '#type' => 'checkbox',
    '#title' => t('Send summary email'),
    '#default_value' => 0,
  ];

  $form['processing']['debug'] = [
    '#type' => 'checkbox',
    '#title' => t('Enable debug logging to file'),
    '#default_value' => 0,
  ];

  //Dedupe Processing Options
  $form['dedupeset'] = [
    '#type' => 'fieldset',
    '#title' => t('Dedupe Processing'),
  ];

  $form['dedupeset']['dedupe'] = [
    '#type' => 'checkbox',
    '#title' => t('Dedupe on import.'),
    '#default_value' => 0,
    '#description' => t('When enabled, imported records will be compared and matched with existing contact records using the selected rule. Records should have first name, last name, suffix, street address, and postal code or email in order to effectively match.'),
  ];

  $rules = CRM_Core_DAO::executeQuery("
    SELECT title, id
    FROM civicrm_dedupe_rule_group
    WHERE contact_type = 'Individual'
    ORDER BY title;");

  $dedupeoptions = [];
  while ($rules->fetch()) {
    $dedupeoptions[$rules->id] = $rules->title;
  }

  $form['dedupeset']['deduperule'] = [
    '#type' => 'select',
    '#options' => $dedupeoptions,
    '#title' => t('Dedupe Rule'),
    '#default_value' => 1,
    '#description' => t('If dedupe is enabled (above), select which rule to use when determining a match. In most cases you will use the Individual Strict rule.'),
  ];

  //Data Handling Options
  $form['datahandling'] = [
    '#type' => 'fieldset',
    '#title' => t('Data Handling'),
  ];

  $form['datahandling']['boeimport'] = [
    '#type' => 'checkbox',
    '#title' => t('Process as a BOE import.'),
    '#default_value' => 0,
    '#description' => t(''),
  ];

  $form['datahandling']['emailimport'] = [
    '#type' => 'checkbox',
    '#title' => t('Process as an email import.'),
    '#default_value' => 0,
    '#description' => t('Enabling will automatically engage dedupe on import using the email import rule. New contacts created during import (which do not match any existing contacts) will be added to an "Email Only" group and excluded from postal mailings.'),
  ];

  $form['datahandling']['addtogroup_handling'] = [
    '#type' => 'radios',
    '#title' => t('Add to Group Handling'),
    '#options' => ['all' => t('Add All'), 'new' => t('Add New'), 'none' => t('None')],
    '#attributes' => ['class' => ['addtogroup_handling-wrapper']],
    '#default_value' => 'none',
    '#description' => t('If "Add All" is selected, all imported contacts will be added to the group. If "Add New" is selected, only new contacts created through the import will be added to the group.'),
  ];

  $form['datahandling']['addtogroup'] = [
    '#type' => 'textfield',
    '#title' => t('Group Name (if the group name does not exist, it will be created)'),
    '#size' => 40,
    '#field_prefix' => '<br />',
  ];

  $form['datahandling']['parsename'] = [
    '#type' => 'checkbox',
    '#title' => t('Parse full name'),
    '#default_value' => 0,
    '#description' => t('Enable this option if your import file contains a full_name field that you want to parse into first/middle/last name. Note, if you enable this option, parsed field names will be ignored.'),
  ];

  $form['datahandling']['fieldoverride'] = [
    '#type' => 'checkbox',
    '#title' => t('Null/empty override'),
    '#default_value' => 0,
    '#description' => t('Enabling this option will allow you to override existing fields with empty values. Standard behavior ignores empty values in your import file, thus retaining existing values in Bluebird. Use with caution.'),
  ];

  $form['datahandling']['greetinggeneration'] = [
    '#type' => 'radios',
    '#title' => t('Greeting Generation'),
    '#options' => [
      'imported' => t('Process Imported Contacts Only'),
      'all' => t('Process All Contacts'),
      'none' => t('Disable Greeting Generation'),
    ],
    '#default_value' => 'imported',
    '#description' => t('By default, only imported contacts will have greetings generated. If you choose, you may run the greeting generation script across the entire database, or disable it altogether.'),
  ];

  $form['import']['submit'] = [
    '#type' => 'submit',
    '#value' => t('Submit'),
  ];

  return $form;
} // nyss_ioimport_form()


//define form validation
function nyss_ioimport_form_validate($form, &$form_state) {
  nyss_iovalidateuploadform($form, $form_state);
} // nyss_ioimport_form_validate()


//process form validation steps
function nyss_iovalidateuploadform($form, &$form_state) {
  //watchdog('io', '<pre>'.print_r($form_state, TRUE).'</pre>');

  if (empty($form_state['values']['csv'])) {
    $form_state['values']['csv'] = [];
  }

  //require either a file be uploaded or referenced on the server
  if (!empty($form_state['values']['servercsv'])) {
    $form_state['values']['csv']['title'] = $form_state['values']['servercsv'];
    $form_state['values']['csv']['file']->uri = '/data/importData/'.$form_state['values']['servercsv'];
    if (!file_exists($form_state['values']['csv']['file']->uri)) {
      form_set_error('servercsv', 'No file by that name was found.');
    }
  }
  else {
    $validators = ['file_validate_extensions' => ['csv tab txt']];
    $file = file_save_upload('csv', $validators);

    if (!$file) {
      form_set_error('csv', 'You must select a valid file to upload.');
    }
    else {
      // Manually add the uploaded file to the $form_state
      //watchdog('io', '<pre>'.print_r($file, TRUE).'</pre>');
      $form_state['values']['csv']['title'] = $file->filename;
      $form_state['values']['csv']['file'] = $file;
    }
  }
  //nyss_out('debug', $file, true); exit();
  //nyss_out('debug', $form_state, true); exit();
} // nyss_iovalidateuploadform()


//main function for processing import
function nyss_ioimport_form_submit($form, &$form_state) {
  //nyss_out("debug", $form_state, true);

  //temporarily bump memory limit
  ini_set('memory_limit', '10000M');

  //track processing time
  $timeStart = time();

  // Load the configuration for this instance
  require_once dirname(__FILE__).'/../../civicrm/scripts/bluebird_config.php';
  $bbconfig = get_bluebird_instance_config();

  global $user;
  global $nyss_ioline;
  global $nyss_iototallines;
  global $nyss_conn;
  global $dryrun;

  civicrm_initialize();

  require_once 'CRM/Core/Config.php';
  require_once 'api/api.php';
  require_once(dirname(__FILE__) . '/nyss_io_definitions.inc');

  $config = CRM_Core_Config::singleton();
  $nyss_conn = nyss_getConnection($bbconfig);

  $filename = $form_state['values']['csv']['file']->uri;
  if (empty($filename)) {
    nyss_out('status','unable to find filename.',true);
  }

  $fo = new NYSS_IOFileObject($filename, "\t");
  $nyss_iototallines = $fo->countLines();

  //initialize some values
  $bImportData = [];
  $nyss_ioline = 0;
  $runnum = $form_state['values']['runnum'];
  $dryrun = $form_state['values']['dryrun'] ?? FALSE;

  $dryrunTxt = 'TRUE';
  if (!$dryrun) {
    $dryrunTxt = 'FALSE';
  }

  //set debug constant
  if (!empty($form_state['values']['debug']) && !defined('NYSSIODEBUG')) {
    define('NYSSIODEBUG', TRUE);
  }
  elseif (!defined('NYSSIODEBUG')) {
    define('NYSSIODEBUG', FALSE);
  }

  $ioOptions = [];
  fillIoGetOptions($ioOptions);

  //get some civicrm values and flip so we can easily lookup values
  $aStates = array_flip(ioGetStates());
  $aGender = array_flip(ioGetOptions('gender', $ioOptions));
  $aPrefix = array_flip(ioGetOptions('individual_prefix', $ioOptions));
  $aSuffix = array_flip(ioGetOptions('individual_suffix', $ioOptions));
  $aLocType = array_flip(ioGetLocType());

  nyss_out('status',
    "importing file with [dryrun = {$dryrunTxt}] AND [count = {$runnum}].<br>import file: {$filename}",
    true );
  nyss_flush();

  //set includes based on column headers
  $columns = $fo->header;
  if (array_key_exists('current_employer', $columns)) {
    require_once 'CRM/Contact/BAO/Contact/Utils.php';
  }

  //include parsename helper if set
  $parse = $form_state['values']['parsename'];
  if ($parse) {
    require_once(dirname(__FILE__).'/nameparse.php');
  }

  //if processing as an email import, set other required options
  if ($form_state['values']['emailimport']==1) {
    $form_state['values']['dedupe'] = 1;
    $form_state['values']['deduperule'] = 1;
  }

  //initialize arrays to be populated with contact id's during import
  $imported_contacts = $updated_contacts = $new_contacts = $delete_contacts = $addressDel = $tagContacts = [];

  while ($l = $fo->getLine()) {
    if ($nyss_ioline%BATCHSIZE == 0) {
      mysqli_query($nyss_conn, "START TRANSACTION");
    }

    //nyss_out('debug', $l, true); //exit();

    //seconds to process each row
    set_time_limit (30);

    //increase line number
    ++$nyss_ioline;

    if (is_numeric($runnum)) {
      if ($form_state['values']['runnum'] <= $nyss_ioline) {
        nyss_out('debug',"Stopping at {$nyss_ioline} lines.", true);
        break;
      }
    }

    if ($nyss_ioline % 500 == 0) {
      nyss_out('status', "processed {$nyss_ioline} lines", true);
      nyss_flush();
    }

    //6998 if delete contact, process and exit
    if (!empty($l['delete_contact']) && $l['delete_contact'] == 1 && !$dryrun) {
      if (!empty($l['id'])) {
        //confirm that id exists
        $sql = "
          SELECT id
          FROM civicrm_contact
          WHERE id = {$l['id']}
        ";

        if (CRM_Core_DAO::singleValueQuery($sql)) {
          $delete_contacts[] = $l['id'];
          CRM_Contact_BAO_Contact::deleteContact($l['id'], false, true);
        }
        else {
          nyss_out('debug', 'contact flagged for deletion but ID is not present in the database. skipping record:', true);
          nyss_out('debug', $l, true);
        }
      }
      else {
        nyss_out('debug', 'contact flagged for deletion but no ID provided. skipping record:', true);
        nyss_out('debug', $l, true);
      }
      continue;
    }

    //fix the gender entries
    _fixGender($l, $aGender);

    //fix birthdate
    _fixBirthdate($l);

    //fix location_type_id if set and not numeric
    _fixLocType($l, $aLocType);

    //fix boe registration date
    _fixBOERegDate($l);

    //4107 parse name
    if ($parse && isset($l['full_name'])) {
      _fixParseName($l);
    }

    //fix prefixes
    _fixPrefix($l, $aPrefix, $nyss_ioprefixes);

    //fix suffixes
    _fixSuffix($l, $aSuffix, $nyss_iosuffixes);

    //set the last import timestamp if address fields are passed
    $addressExists = false;
    foreach ($nyss_iofields['civicrm_address'] as $field => $dontcare) {
      if (array_key_exists($field, $l) || $form_state['values']['fieldoverride']) {
        $l['last_import_57'] = date('Y-m-d H:i:s');
        $addressExists = true;
        break;
      }
    }

    //if dedupe selected and no contact id, lookup contact in db
    if ($form_state['values']['dedupe'] && empty($l['id'])) {
      _findContact($l, $nyss_conn, $form_state['values']['deduperule']);
      //nyss_out('debug', $l, true); exit();
    }

    //look for existing related record in custom table
    if (!empty($l['id'])) {
      _findRelatedCustom($l, $nyss_conn);
    }

    //BOE imports
    if ($form_state['values']['boeimport']) {
      //set all addresses as BOE type
      $l['location_type_id'] = 6;

      //set contact source to BOE
      $l['contact_source_60'] = 'boe';

      //set voter registration status to registered
      $l['voter_registration_status_23'] = 'registered';
    }

    //set state id
    _fixState($l, $aStates);

    //if street_unit value exists, and there is no "apt" text, prepend to value
    _fixStreetUnit($l);

    //form the street address if we are provided parsed values; convert proper case first
    _fixStreetAddress($l);

    //if street_number set, let's parse into street_number and street_number_suffix
    _fixStreetNumber($l);

    //strip leading/trailing/double spaces for all imported data; escape all single quotes
    _cleanData($l);

    //identify addresses to be deleted and store for later processing
    //do before we perform an address_id lookup as we only want addresses
    //for which an ID was explicitly passed
    if (!empty($l['address_id']) && strtolower($l['street_address']) == 'delete') {
      $addressDel[] = $l['address_id'];
    }

    //find an address if we don't have an addressID already
    _findAddress($l, $nyss_conn);

    //find district id if address id set
    _findDistrict($l, $nyss_conn);

    //find email id if email is set
    _findEmail($l, $nyss_conn);

    //nyss_out('debug', 'ready to begin importing record...', true);
    //nyss_out('debug', $l, true); exit();

    /*------NOW IMPORT THE DATA-------------------------------------*/

    //import contact details
    $new_contact = (!array_key_exists('id',$l) || empty($l['id']));
    nyss_ioimportData('civicrm_contact', $l, $dryrun, $form_state);

    //sort the contacts into groups for later use
    if (!$dryrun) {
      $imported_contacts[] = $l['id'];
      if ($new_contact) {
        $new_contacts[] = $l['id'];
      }
      else {
        $updated_contacts[] = $l['id'];
      }
    }
    else {
      $imported_contacts[] = 0;
      if ($new_contact) {
        $new_contacts[] = 0;
      }
      else {
        $updated_contacts[] = 0;
      }
    }

    //import address details; set key correctly for ref
    $l['contact_id'] = $l['id'];
    if ($addressExists) {
      nyss_ioimportData('civicrm_address', $l, $dryrun,$form_state);
    }

    //import phone details; set key correctly for ref
    $l['phone_contact_id'] = $l['contact_id'];
    nyss_ioimportData('civicrm_phone', $l, $dryrun, $form_state);

    //import email details; set key correctly for ref
    $l['email_contact_id'] = $l['contact_id'];
    nyss_ioimportData('civicrm_email', $l, $dryrun, $form_state);

    //import contact source details; set key correctly for ref
    $l['constinfo_entity_id'] = $l['id'];
    nyss_ioimportData('civicrm_value_constituent_information_1', $l, $dryrun, $form_state);

    //import district details; set key correctly for ref (ID is for addresses)
    $l['entity_id'] = $l['address_id'];
    nyss_ioimportData('civicrm_value_district_information_7', $l, $dryrun, $form_state);

    //process special fields using API/BAO
    _processCurrentEmployer($l, $nyss_conn, $dryrun);

    //process pipe separated list of keywords
    if (!empty($l['keywords'])) {
      $keywords = explode('|', str_replace(['| ','"'], ['|',''], $l['keywords']));
      foreach ($keywords as $keyword) {
        $tagContacts['Keywords'][$keyword][] = $l['id'];
      }
    }

    //process pipe separated list of website petitions
    if (!empty($l['petitions'])) {
      $petitions = explode('|', str_replace(['| ','"'], ['|',''], $l['petitions']));
      foreach ($petitions as $petition) {
        $tagContacts['Website Petitions'][$petition][] = $l['id'];
      }
    }

    _processNote($l, $nyss_conn);

    if ($nyss_ioline%BATCHSIZE == 0) {
      mysqli_query($nyss_conn, "COMMIT");
    }

    unset($l);
  }//end $l record processing

  // Commit any stragglers!
  if ($nyss_ioline%BATCHSIZE!=0) {
    mysqli_query($nyss_conn, "COMMIT" );
  }

  //track processing time
  $timeEnd  = time();
  $timeDiff = $timeEnd - $timeStart;
  nyss_out('status',"Processing time: $timeDiff sec.",true);

  //Begin post process
  nyss_out('debug', "file rows import complete. beginning post process steps.", true);

  //variable stats
  if (VARSTATS) {
    nyss_out('debug', 'generating details about variables', true);

    $varDetails = [];
    $vars = get_defined_vars();
    //nyss_out('debug', $vars, true);

    foreach ($vars as $set => $var) {
      $start_memory = memory_get_usage(true);
      $tmp = unserialize(serialize($var));
      $diff = memory_get_usage(true) - $start_memory - PHP_INT_SIZE * 8;
      $varDetails[$set] = convertSize($diff);
    }

    nyss_out('debug', $varDetails, true);
  }

  //tag processing
  if (!empty($tagContacts)) {
    foreach ($tagContacts as $type => $tagList) {
      _processTags($tagList, $type);
    }
  }

  //track processing time
  $timeEnd  = time();
  $timeDiff = $timeEnd - $timeStart;
  nyss_out('status',"Processing time: $timeDiff sec.",true);

  //add contacts to group if set
  _processGroup($form_state, $imported_contacts, $new_contacts, $dryrun);

  //track processing time
  $timeEnd  = time();
  $timeDiff = $timeEnd - $timeStart;
  nyss_out('status',"Processing time: $timeDiff sec.",true);

  //add all new contacts to the email only group
  if ($form_state['values']['emailimport'] == 1) {
    _processEmailImport($new_contacts, $nyss_conn);
  }

  //delete addresses flagged for deletion
  $addressDelCount = count($addressDel);
  _processAddressDelete($addressDel, $nyss_conn, $dryrun);

  //track processing time
  $timeEnd  = time();
  $timeDiff = $timeEnd - $timeStart;
  nyss_out('status',"Processing time: $timeDiff sec.",true);

  //send email if requested
  if ($form_state['values']['sendmail'] == 1) {
    nyss_out('debug', "processing log email...", true);

    //now send a confirmation email
    $message = [
      'to' => $user->mail,
      'subject' => 'import Data Summary'.Date("Y-m-d H:i:s"). " filename: {$filename}",
      'body' => 'download the import report here: '.urlencode("http://".$_SERVER['HTTP_HOST'].'/nyss_getfile?file='.urlencode($filename)),
      'headers' => ['From' => 'import@cms.nysenate.gov'],
    ];
    drupal_mail_send($message);
  }

  $num_updated = count($updated_contacts);
  $num_created = count($new_contacts);
  $num_deleted = count($delete_contacts);

  nyss_out('status', "$num_updated updated, $num_created created.", true);
  nyss_out('status', "$num_deleted deleted.", true);
  nyss_out('status', "$addressDelCount addresses deleted.", true);
  nyss_out('status', "Imported $nyss_ioline lines.",true);

  //various postProcessing cleanup steps
  if (!$dryrun) {
    nyss_out('debug', "post process cleanup steps...", true);

    $bbconfig = get_bluebird_instance_config();

    //run duplicate primary flag cleanup
    $dupePriScript = $bbconfig['app.rootdir'].'/scripts/fixDupePrimary.sh '.$bbconfig['shortname'];
    $dupePriCleanup = shell_exec($dupePriScript);
    nyss_out('status', $dupePriCleanup, true);

    //track processing time
    $timeEnd  = time();
    $timeDiff = $timeEnd - $timeStart;
    nyss_out('status',"Processing time: $timeDiff sec.",true);

    //run greetings update on all null values unless disable greeting option is selected
    nyss_out('debug', "greeting generation using option: {$form_state['values']['greetinggeneration']}...", true);
    if ($form_state['values']['greetinggeneration'] != 'none') {
      $tblOpt = '';
      if ($form_state['values']['greetinggeneration'] == 'imported') {
        //if only processing imported, we store in a temp table and pass the table name to the greeting script
        $rnd = date('Ymdhis');
        $tmpTbl = "nyss_temp_greetings_$rnd";
        nyss_out('debug', "tmpTbl: {$tmpTbl}", true);
        $sql = "CREATE TABLE $tmpTbl (id INT NOT NULL PRIMARY KEY) ENGINE = myisam;";
        CRM_Core_DAO::executeQuery($sql);

        //insert ids from stored arrays
        $allIDs = array_merge($updated_contacts, $new_contacts);
        $sql = "INSERT IGNORE INTO {$tmpTbl} (id) VALUES (".implode('), (',$allIDs).")";
        CRM_Core_DAO::executeQuery($sql);

        $tblOpt = " --idtbl={$tmpTbl}";
      }

      $greetingScript = 'php '.$bbconfig['app.rootdir'].'/civicrm/scripts/updateAllGreetings.php -S '.$bbconfig['shortname'].' --quiet'.$tblOpt;
      $greetingCreate = shell_exec($greetingScript);
      nyss_out('status', $greetingCreate, true);

      //track processing time
      $timeEnd  = time();
      $timeDiff = $timeEnd - $timeStart;
      nyss_out('status',"Processing time: $timeDiff sec.",true);
    }

    //check for malformed emails and place on hold
    $flagEmailScript  = $bbconfig['app.rootdir'].'/scripts/flagBadEmails.sh --ok '.$bbconfig['shortname'];
    $flagEmailCleanup = shell_exec($flagEmailScript);
    nyss_out('status', $flagEmailCleanup, true);
  }

  //track processing time
  $timeEnd  = time();
  $timeDiff = $timeEnd - $timeStart;
  nyss_out('status',"Processing time: $timeDiff sec.",true);
  nyss_out('status','<a href="">click here</a> to continue and return to the import page.',true);

  exit();
} // nyss_ioimport_form_submit()


function nyss_ioimportData($tbl, &$l, $dryrun, $form_state)
{
  //nyss_out('debug', "tbl top: $tbl", true);
  //nyss_out('debug', $l, true);

  global $nyss_iofields;
  global $nyss_select;
  global $nyss_ioline;
  global $nyss_conn;

  //build the select array once and store global for efficiency
  if (empty($nyss_select)) {
    $nyss_select = [];
    foreach ($nyss_iofields as $table=>$tableDetails) {
      $tmp = [];
      foreach ($tableDetails as $key => $importField) {
        $tmp[] = "`{$importField['fld']}` as '{$key}'";

        if (isset($importField['PK']) && $importField['PK']) {
          $nyss_select[$table]['PK']['importField'] = $key;
          $nyss_select[$table]['PK']['civiField'] = $importField['fld'];
        }

        if (!empty($importField['FK'])) {
          $nyss_select[$table]['FK']['fkAlias'] = $importField['FK']['fk_alias'];
          $nyss_select[$table]['FK']['fkField'] = $importField['fld'];
          $nyss_select[$table]['FK']['fkMap'] = $importField['FK'];
        }
      }
      $nyss_select[$table]['fields'] = implode(",",$tmp);
    }
  }

  $pkCivi = $nyss_select[$tbl]['PK']['civiField'];
  $pkImport = $nyss_select[$tbl]['PK']['importField'];

  $prefixes = ioGetOptions("individual_prefix", $ioOptions);
  $suffixes = ioGetOptions("individual_suffix", $ioOptions);

  //nyss_out('debug', $nyss_select, true);
  //nyss_out('debug', "pkCivi: $pkCivi", true);
  //nyss_out('debug', "pkImport: $pkImport", true);
  //nyss_out('debug', "fields: {$nyss_select[$tbl]['fields']}", true);
  //nyss_out('debug', $l, true);

  //11516 if passed an ID, verify before determining update/insert
  if (!empty($l[$pkImport])) {
    $sql = "
      SELECT {$nyss_select[$tbl]['fields']} 
      FROM {$tbl} 
      WHERE {$pkCivi} = {$l[$pkImport]}
    ";
    //nyss_out('debug', 'record Id Check:', true);
    //nyss_out('debug', $sql, true);
    $result = mysqli_query($nyss_conn, $sql);
    if (!$result || mysqli_num_rows($result) == 0) {
      nyss_out('error', 'attempting to update but no existing record found. skipping...', TRUE);
      mysqli_free_result($result);
      return;
    }
  }

  //11516 also check if a foreign key relationship exists
  $fkDetails = $nyss_select[$tbl]['FK'];
  //nyss_out('debug', 'fkDetails:', true);
  //nyss_out('debug', $fkDetails, true);
  if (!empty($fkDetails) && !empty($l[$fkDetails['fkAlias']])) {
    $sql = "
      SELECT {$fkDetails['fkMap']['fk_id']}
      FROM {$fkDetails['fkMap']['table']}
      WHERE {$fkDetails['fkMap']['fk_id']} = {$l[$fkDetails['fkAlias']]}
    ";
    //nyss_out('debug', 'fk Check:', true);
    //nyss_out('debug', $sql, true);
    $result = mysqli_query($nyss_conn, $sql);
    if (!$result || mysqli_num_rows($result) == 0) {
      nyss_out('error', 'attempting to update related record but no FK match found. skipping...', TRUE);
      mysqli_free_result($result);
      return;
    }
  }

  //if we are passed a key, update; else insert
  if (!empty($l[$pkImport])) {
    //nyss_out('status', 1, true);
    //nyss_out('debug', $pkCivi, true);
    //nyss_out('debug', $pkImport, true);
    //nyss_out('debug', $l, true);

    //get results from query above
    $dao = mysqli_fetch_object($result);
    mysqli_free_result($result);

    $up = [];

    //compare the fields
    foreach ($l as $key=>$data) {

      //apply handler if set
      if (isset($nyss_iofields[$tbl][$key]['handler'])) {
        $data = $nyss_iofields[$tbl][$key]['handler']($data, true);
      }

      //echo 'existing: '.$dao->$key.'<br />';
      //echo 'new: '.$data.'<br /><br />';
      //if the import data doesn't match civi data, update it
      if (isset($nyss_iofields[$tbl][$key]) &&
          ($dao->$key<>$data || $form_state['values']['fieldoverride'])) {
        //add to the update statement
        if (!empty($data) || $form_state['values']['fieldoverride']) {
          if (empty($data)) {
            $up[] = "{$nyss_iofields[$tbl][$key]['fld']}=NULL";
          }
          else {
            $up[] = "{$nyss_iofields[$tbl][$key]['fld']}='{$data}'";
          }
        }

        //if address is being updated, set lat/lon to null for reprocessing
        if ($key = 'street_address' &&
             (empty($l['geo_code_1']) || empty($l['geo_code_2']))) {
          $l['geo_code_1'] = null;
          $l['geo_code_2'] = null;
        }
      }
    }

    //if there is something to update, do it!
    if (!empty($up)) {
      $sqlUP = "UPDATE {$tbl} SET ".implode(',',$up). " WHERE {$pkCivi}={$l[$pkImport]}";
      //print_r($sqlUP."<br>");

      if (!$dryrun) {
        $result = mysqli_query($nyss_conn, $sqlUP);
      }
      else {
        //if ($tbl=='civicrm_value_constituent_information_1' || $tbl=='civicrm_value_district_information_7') {
        print_r($sqlUP."<br>"); //debug
        //}
      }
      nyss_out('debug', "line {$nyss_ioline}: updated record. " . $sqlUP, FALSE);
    }
    else {
      nyss_out('debug', "line {$nyss_ioline}: nothing to update for $tbl record: " . implode(',',$l), FALSE);
    }
  }
  //otherwise just insert
  else {
    $skip = false;
    $sqlINSERT  = "";
    $insertKeys = [];

    //nyss_out('debug', $l, true);
    $up = [];

    //first set a few additional values required for insert action
    //TODO we should have a large switch statement to condition ton $tbl so we don't process multiple times

    //contact record work
    if ($tbl == 'civicrm_contact') {
      $l['contact_type'] = 'Individual';
      $suffix = (!empty($l['suffix_id']) && !empty($suffixes[$l['suffix_id']])) ? ', '.$suffixes[$l['suffix_id']] : '';
      //account for both possible field names
      $l['middle_name'] = (!empty($l['mid'])) ? $l['mid'] : $l['middle_name'];
      //need to propercase these values before constructing display and sort name
      $fnc = trim(convertProperCase($l['first_name'], true));
      $mnc = trim(convertProperCase($l['middle_name'], true));
      $fnc = ($mnc) ? $fnc.' ' : $fnc;
      $lnc = trim(convertProperCase($l['last_name'], true));
      $prefix = (!empty($l['prefix_id']) && !empty($prefixes[$l['prefix_id']])) ? $prefixes[$l['prefix_id']] : '';
      $display_name = $prefix.' '.$fnc.$mnc.' '.$lnc.$suffix;
      $l['display_name'] = nyss_stripSpaces($display_name);

      if (!empty($l['display_name'])) {
        $l['sort_name'] = $lnc.', '.$fnc.$mnc.$suffix;
      }
      elseif (!empty($l['current_employer'])) {
        //if display name is empty, we have no indiv name data; if current_employer is set, we can assume org contact
        $l['contact_type'] = 'Organization';
        $l['display_name'] = $l['sort_name'] = $l['organization_name'] = $l['current_employer'];
        $l['current_employer'] = '';
      }
    }

    //only set these if the corresponding data columns exist in the import file
    //nyss_out('debug', $l, true);exit();
    if (!empty($l['street_address']) ||
      (!empty($l['supplemental_address_1']))
    ) {
      if ($form_state['values']['boeimport']) {
        $l['location_type_id'] = 6; //set address type to BOE
      }
      elseif (empty($l['location_type_id']) || !array_key_exists('location_type_id', $l)) {
        $l['location_type_id'] = 1; //set address type to Home if not set by importer
      } //else use as set in the import file

      if (!array_key_exists('address_is_primary', $l)) {
        //if contact has no existing address, set to primary
        if (!_addressExists($l)){
          $l['address_is_primary'] = 1;
        }
      }
      $l['country_id'] = 1228; //assume US
    }

    if (!empty($l['phone'])) {
      $l['phone_type_id'] = 1; //set to phone
      if (empty($l['phone_location_type_id'])) {
        $l['phone_location_type_id'] = 1; //set to home
      }
      if (empty($l['phone_is_primary'])) {
        $l['phone_is_primary'] = 1; //set to primary
      }
    }
    else {
      //if no phone value, unset the contact_id so empty record is not created; TODO: handle higher in the process
      unset($l['phone_contact_id']);
    }

    if (!empty($l['email'])) {
      if (!$l['email_location_type_id']) {
        $l['email_location_type_id'] = 1; //set to home
      }
      if (!$l['email_is_primary']) {
        $l['email_is_primary'] = 1; //set to primary
      }
    }
    else {
      //if no email value, unset the contact_id so empty record is not created; TODO: handle higher in the process
      unset($l['email_contact_id']);
    }

    //nyss_out('debug', $tbl, true);
    //nyss_out('debug', $l, true); //exit();

    //set up the insert
    //nyss_out('status', 'set up the insert', true);
    foreach($l as $key => $data) {
      //unset if no data
      if (empty($data) && $data !== 0 &&
        isset($nyss_iofields[$tbl]) &&
        array_key_exists($key, $nyss_iofields[$tbl])
      ) {
        unset($l[$key]);
        continue;
      }

      //apply handler if set
      if (isset($nyss_iofields[$tbl][$key]['handler'])) {
        $data = $nyss_iofields[$tbl][$key]['handler']($data, true);
      }

      //make sure we're only processing the records for that table
      if (!isset($nyss_iofields[$tbl][$key])) continue;

      //echo 'field to be processed: ';
      //nyss_out('debug', $key.'::'.$data, true);
      $up = [];

      //skip if required values not found
      if (empty($data) && $nyss_iofields[$tbl][$key]['required']) {
        $skip = true;
        break;
      }

      //skip if no data
      if (empty($data) && $data !== 0) {
        continue;
      }

      $insertKeys[] = "`{$nyss_iofields[$tbl][$key]['fld']}`";
      $insertData[] = "'{$data}'";
    }

    //nyss_out('debug', $l, true); //exit();

    if ($skip) return;

    if ($insertKeys && $insertData) {
      $sqlINSERT = "INSERT INTO {$tbl} (".implode(',',$insertKeys).") VALUES (".implode(',',$insertData).")";
      //nyss_out('debug', $sqlINSERT, true);
    }

    //process if sql insert exists and not dryrun
    if (!$dryrun && $sqlINSERT) {
      $result = mysqli_query($nyss_conn, $sqlINSERT) or die(mysqli_error($nyss_conn));
      $l[$pkImport] = mysqli_insert_id($nyss_conn);
    }
    elseif ($sqlINSERT) {
      print_r($sqlINSERT."<br>"); //debug
    }

    nyss_out('debug', "line {$nyss_ioline}: inserted record. " . $sqlINSERT, FALSE);
  }
} // nyss_ioimportData()


function fillIoGetOptions(&$ioOptions)
{
  $session = & CRM_Core_Session::singleton();
  $dao = &CRM_Core_DAO::executeQuery("SELECT id, name FROM civicrm_option_group;");

  $optionGroups = [];
  while($dao->fetch())
  {
    $optionGroups[$dao->id] = $dao->name;
  }

  $dao = &CRM_Core_DAO::executeQuery("SELECT id, option_group_id, name, label, value FROM civicrm_option_value");
  $options = [];
  while($dao->fetch())
  {
    $name = (strlen($dao->label) > 0) ? $dao->label : $dao->name;
    $options[$optionGroups[$dao->option_group_id]][$dao->value] = $name;
  }
  $ioOptions = $options;
} // fillIoGetOptions()


function ioGetOptions($strGroup, &$ioOptions)
{
  if (isset($ioOptions[$strGroup]) && !is_null($ioOptions[$strGroup]) && is_array($ioOptions[$strGroup])) {
    return $ioOptions[$strGroup];
  }
  return [];
} // ioGetOptions()


function ioGetStates() {
  //lookup US states only
  $dao = CRM_Core_DAO::executeQuery("
    SELECT id, abbreviation
    FROM civicrm_state_province
    WHERE country_id = 1228
  ");

  $options = [];
  while ($dao->fetch()) {
    $options[$dao->id] = $dao->abbreviation;
  }

  return $options;
} // ioGetStates()


function ioGetLocType() {
  $session =& CRM_Core_Session::singleton();
  $dao = &CRM_Core_DAO::executeQuery("SELECT id, name FROM civicrm_location_type;");
  $options = [];
  while ($dao->fetch()) {
    $options[$dao->id] = $dao->name;
  }

  return $options;
} // ioGetLocType()


function convertProperCase($string, $skipMixed = false, $skipSpecial = false)
{
  //if mixed case, don't do anything
  if ($skipMixed && preg_match('/[a-z]/', $string)) return $string;

  $string = CRM_Utils_String::stripSpaces(ucwords(strtolower($string)));

  //if we skip special words processing, return now
  if ($skipSpecial) return $string;

  // list of words we want to force
  $forceWords = [
    'of', 'the', 'and', 'an', 'or', 'nor', 'but', 'is', 'if', 'then',
    'else', 'when', 'at', 'from', 'by', 'on', 'off', 'for', 'in', 'out', 'over', 'to',
    'into', 'with', 'II', 'IV', 'UK', 'VI', 'III', 'VII', 'PO', 'McDonald', 'McClelland', 'RR'
  ];

  // punctuation used to determine that the following letter
  // should be capitalised
  $punctuation = [
    '.', '-', ':', '!', '\'', '-', '?'
  ];

  $words = explode(' ', $string);

  foreach ($words as $word) {

    $replace = [];

    //trim any non-word chars and replace with nothing for easier matching
    $cleanWord = preg_replace("/[^\w]/", '', $word);
    //nyss_out('debug', "cleanWord: $cleanWord", true);
    if (!empty($cleanWord)) $replace = preg_grep("/\b{$cleanWord}\b/i", $forceWords);

    $replace = array_values($replace);
    //nyss_out('debug', $replace, true);
    if (isset($replace[0])) $word = str_replace($cleanWord,$replace[0],$word);

    //if number followed by letter, uppercase
    if (preg_match("/^\d[a-z]/", $cleanWord)) {
      $word = strtoupper(($word));
    }

    $fixedWords[] = $word;
  }

  //nyss_out('debug', $fixedWords, true);
  $string = implode(' ',$fixedWords);

  return $string;
} // convertProperCase()


function checkTagIndex()
{
  $sql = "
    SHOW INDEX FROM civicrm_entity_tag
    WHERE key_name = 'UI_entity_id_entity_table_tag_id'
  ";
  $ti = CRM_Core_DAO::singleValueQuery($sql);

  if (!$ti) {
    //remove duplicates and add index
    $bbconfig = get_bluebird_instance_config();

    //run duplicate primary flag cleanup
    $fixET = $bbconfig['app.rootdir'].'/scripts/fixEntityTags.sh --dups-only --ok '.$bbconfig['shortname'];
    $fixETout = shell_exec($fixET);
    nyss_out('status', $fixETout, true);

    //create index
    $sql = "
      ALTER TABLE civicrm_entity_tag
      ADD UNIQUE UI_entity_id_entity_table_tag_id
        (entity_table, entity_id, tag_id)
    ";
    CRM_Core_DAO::executeQuery($sql);
    nyss_out('status', 'index created: UI_entity_id_entity_table_tag_id', true);
  }

  //remove old duplicate index
  $sql = "
    SHOW INDEX FROM civicrm_entity_tag
    WHERE key_name = 'index_civicrm_entity_tag_entity_table_entity_id_tag_id'";
  $ti = CRM_Core_DAO::singleValueQuery($sql);

  if ($ti) {
    $sql = "
      DROP INDEX index_civicrm_entity_tag_entity_table_entity_id_tag_id
      ON civicrm_entity_tag;
    ";
    CRM_Core_DAO::executeQuery($sql);
  }

  return;
} // checkTagIndex()


/*
 * generate details about what variables exist and how much memory they consume
 */
function nyss_vars()
{
  nyss_out('debug', 'generating details about variables', true);

  $varDetails = [];
  $vars = get_defined_vars();
  nyss_out('debug', $vars, true);
  foreach ($vars as $type => $set) {
    foreach ($set as $var) {
      $start_memory = memory_get_usage();
      $tmp = unserialize(serialize($var));
      $diff = memory_get_usage() - $start_memory;
      $varDetails[$type][$var] = $diff;
    }
  }
  nyss_out('debug', $varDetails, true);
} // nyss_vars()


function convertSize($size)
{
  $unit = ['b','kb','mb','gb','tb','pb'];
  return @round($size/pow(1024,($i=floor(log($size,1024)))),2).' '.$unit[$i];
} // convertSize()


function _fixGender(&$l, $aGender)
{
  if (!empty($l['gender'])) {
    $gender_key = 'gender';
  }
  elseif (!empty($l['gender_id'])) {
    $gender_key = 'gender_id';
  }

  if (!empty($gender_key)) {
    switch ($l[$gender_key]) {
      case 'M':
        $l['gender'] = 'Male';
        break;
      case 'F':
        $l['gender'] = 'Female';
        break;
    }

    $l['gender_id'] = $aGender[$l['gender']];

    //remove text value
    unset($l['gender']);
  }
} // _fixGender()


function _fixBirthdate(&$l)
{
  if (isset($l['birth_date'])) {
    $d = $l['birth_date'];

    //remove/exclude errant records
    if (!empty($d) && $d != 0 && $d != 19000101 && $d != 19010101 && $d > 19000000) {
      $l['birth_date'] = substr($d,0,4).'-'.substr($d,4,2).'-'.substr($d,6,2);
    }
    else {
      $l['birth_date'] = null;
    }
  }
} // _fixBirthdate()


function _fixLocType(&$l, $aLocType)
{
  if (isset($l['location_type_id']) && !is_numeric($l['location_type_id'])) {
    $lti = $l['location_type_id'];
    $l['location_type_id'] = $aLocType[$lti];
  }
} // _fixLocType()


function _fixBOERegDate(&$l)
{
  if (isset($l['boe_date_of_registration_24'])) {
    $boe_reg = $l['boe_date_of_registration_24'];

    //remove errant records
    if (!empty($boe_reg) && $boe_reg != 0 && $boe_reg != 19000101 && $boe_reg != 19010101) {
      $l['boe_date_of_registration_24'] = substr($boe_reg,0,4).'-'.substr($boe_reg,4,2).'-'.substr($boe_reg,6,2);
    }
    else {
      $l['boe_date_of_registration_24'] = null;
    }
  }
} // _fixBOERegDate()


function _fixParseName(&$l)
{
  $parsedValues = parse_name($l['full_name']);

  $l['prefix_id']   = $parsedValues['title'];
  $l['first_name']  = $parsedValues['first'];
  $l['middle_name'] = $parsedValues['middle'];
  $l['last_name']   = $parsedValues['last'];
  $l['suffix_id']   = $parsedValues['suffix'];

  //if parser found fname and no lname, we swap and assume it was an lname found
  if (!empty($l['first_name']) && empty($l['last_name'])) {
    $l['last_name']  = $l['first_name'];
    $l['first_name'] = '';
  }
} // _fixParseName()


function _fixPrefix(&$l, $aPrefix, $nyss_ioprefixes)
{
  if (isset($l['prefix_id'])) {
    $prefix_val = '';

    //if a valid value, retain
    if (array_key_exists($l['prefix_id'], $aPrefix)) {
      $prefix_val = $l['prefix_id'];
    }
    //check if in prefix map
    elseif (array_key_exists(strtoupper($l['prefix_id']), $nyss_ioprefixes)) {
      $prefix_val = $nyss_ioprefixes[strtoupper($l['prefix_id'])];
    }
    //if odd, ignore
    else {
      $prefix_val = '';
    }

    $l['prefix_id'] = $aPrefix[$prefix_val];
  }
} // _fixPrefix()


function _fixSuffix(&$l, $aSuffix, $nyss_iosuffixes)
{
  if (isset($l['suffix_id'])) {
    //if a valid value, retain
    if (array_key_exists($l['suffix_id'], $aSuffix)) {
      $l['suffix_id'] = $aSuffix[$l['suffix_id']];
    }
    //check if in suffix map
    elseif (array_key_exists(strtoupper($l['suffix_id']), $nyss_iosuffixes)) {
      $l['suffix_id'] = $aSuffix[$nyss_iosuffixes[strtoupper($l['suffix_id'])]];
    }
    //if odd, ignore
    else {
      $l['suffix_id'] = '';
    }
  }
} // _fixSuffix()


function _fixState(&$l, $aStates)
{
  if (!empty($l['st']) && !empty($aStates[$l['st']]) ) {
    $l['state_province_id'] = $aStates[$l['st']];
  }
  else if (!empty($l['state_province_id']) && !empty($aStates[$l['state_province_id']]) ) {
    $l['state_province_id'] = $aStates[$l['state_province_id']];
  }
  else {
    $l['state_province_id'] = "";
  }
} // _fixState()


function _fixStreetUnit(&$l)
{
  if (isset($l['street_unit']) && $l['street_unit']) {
    $needle_found = 0;
    $unit_needles = [
      'apt',
      'unit',
      'super',
      'sup',
      'supt',
      'ste',
      'rm',
      'pvt',
      'fl',
      'bsmt',
      'lot',
    ];

    foreach ($unit_needles as $unit_needle) {
      $needle_search = stripos($l['street_unit'], $unit_needle);
      if ($needle_search !== false) {
        $needle_found = 1;
      }
    }

    if (!$needle_found) {
      $l['street_unit'] = 'Apt. '.$l['street_unit'];
    }
  }
} // _fixStreetUnit()


function _fixStreetAddress(&$l)
{
  if (!empty($l['street_name'])) {
    $so = convertProperCase($l['street_number'], true);
    $sn = convertProperCase($l['street_name'], true);
    $su = convertProperCase($l['street_unit'], true);
    $l['street_address'] = $so.' '.$sn;

    if ($su) {
      $l['street_address'] = $l['street_address'].', '.$su;
    }
  }
  elseif (!empty($l['street_address'])) {
    //else if we're provided street_address, send through parser
    require_once 'CRM/Core/BAO/Address.php';
    $parsedFields = CRM_Core_BAO_Address::parseStreetAddress($l['street_address']);
    //nyss_out('debug', $parsedFields, true); exit();

    $l['street_number'] = $parsedFields['street_number'];
    $l['street_name'] = $parsedFields['street_name'];
    $l['street_unit'] = $parsedFields['street_unit'];
  }
} // _fixStreetAddress()


function _fixStreetNumber(&$l)
{
  //borrowed from CRM_Core_BAO_Address::parseStreetAddress()
  if (isset($l['street_number']) && !empty($l['street_number'])) {
    $streetNumAndSuffix = $l['street_number'];
    $matches = [];
    if (preg_match('/^(\d+)/', $streetNumAndSuffix, $matches)) {
      $l['street_number'] = $matches[0];
      $suffix = preg_replace('/^(\d+)/', '', $streetNumAndSuffix);
      $l['street_number_suffix'] = trim($suffix);
      $matches = [];
    }
  }
} //_fixStreetNumber()


function _findContact(&$l, $nyss_conn, $ruleID = 1) {
  require_once 'CRM/Dedupe/Finder.php';

  //format params to pass to dedupe tool
  $params = [
    'civicrm_contact' => [
      'first_name' => $l['first_name'],
      'middle_name' => $l['middle_name'],
      'last_name' => $l['last_name'],
      'suffix_id' => $l['suffix_id'],
      'postal_code' => $l['postal_code'],
    ],
  ];

  if ($l['street_address'] && !empty($l['street_address'])) {
    $params['civicrm_address']['street_address'] = $l['street_address'];
  }
  else {
    $params['civicrm_address']['street_address'] = $l['street_number'].' '.$l['street_name'].' '.$l['street_unit'];
  }

  if (array_key_exists('email',$l) && !empty($l['email'])) {
    $params['civicrm_email']['email'] = $l['email'];
  }

  $params = CRM_Dedupe_Finder::formatParams($params, 'Individual');
  $params['check_permission'] = 0;

  $ruleTitle = CRM_Core_DAO::singleValueQuery("
    SELECT title
    FROM civicrm_dedupe_rule_group
    WHERE id = {$ruleID}
  ");


  $o = new stdClass();
  $o->title = $ruleTitle;
  $o->params = $params;
  $o->noRules = false;
  $tableQueries = [];
  nyss_dedupe_civicrm_dupeQuery($o, 'table', $tableQueries);

  $sql = $tableQueries['civicrm.custom.5'];
  $sql = "
    SELECT contact.id
    FROM civicrm_contact as contact JOIN ($sql) as dupes
    WHERE dupes.id1 = contact.id AND contact.is_deleted = 0
  ";

  if (!$result = mysqli_query($nyss_conn, $sql) ) {
    CRM_Core_Error::debug('sql', $sql);
    var_dump(mysqli_error($nyss_conn)); exit();
  }

  $dupeIDs = [];
  while($row = mysqli_fetch_assoc($result)) {
    $dupeIDs[] = $row['id'];
  }

  //if dupe found, set contact import id
  if (is_array($dupeIDs) && !empty($dupeIDs)) {
    $l['id'] = $dupeIDs[0];
  }

  mysqli_free_result($result);

  //now unset all vars/objects
  unset($params);
  unset($o);
  unset($sql);
  unset($tableQueries);
  unset($row);
  unset($dupeIDs);
  unset($result);
} //_findContact()


function _findRelatedCustom(&$l, $nyss_conn)
{
  $sql = "
    SELECT id AS constinfo_id
    FROM civicrm_value_constituent_information_1
    WHERE entity_id = {$l['id']}
  ";
  $result = mysqli_query($nyss_conn, $sql);

  if ($result && $row = mysqli_fetch_assoc($result)) {
    $l['constinfo_id'] = $row['constinfo_id'];
  }

  mysqli_free_result($result);
} // _findRelatedCustom()


function _findAddress(&$l, $nyss_conn) {
  if (!empty($l['id']) && empty($l['address_id'])) {
    $sql = "
      SELECT id AS address_id, is_primary AS address_is_primary
      FROM civicrm_address
      WHERE contact_id = {$l['id']}
        AND street_number = '{$l['street_number']}'
        AND street_name = '{$l['street_name']}'
        AND city = '{$l['city']}'
        AND postal_code = '{$l['postal_code']}'
    ";
    //nyss_out('debug', $sql, true); exit();
    $result = mysqli_query($nyss_conn, $sql);

    if ($result && $row = mysqli_fetch_assoc($result)) {
      $l['address_id'] = $row['address_id'];
      $l['address_is_primary'] = $row['address_is_primary'];
      //reset primary flag here to prevent being overwritten by the import file
      //due to unexpected lookup/match with existing record
    }

    mysqli_free_result($result);
    unset($row);
    unset($sql);
    unset($result);
  }
} // _findAddress()


function _findDistrict(&$l, $nyss_conn) {
  if (!empty($l['address_id']) && empty($l['districtinfo_id'])) {
    $sql = "
      SELECT id AS districtinfo_id FROM civicrm_value_district_information_7 WHERE entity_id = {$l['address_id']}
    ";
    $result = mysqli_query($nyss_conn, $sql);

    if ($result && $row = mysqli_fetch_assoc($result)) {
      $l['districtinfo_id'] = $row['districtinfo_id'];
    }

    mysqli_free_result($result);
    unset($sql);
    unset($row);
    unset($result);
  }
} // _findDistrict()


function _findEmail(&$l, $nyss_conn)
{
  if (!empty($l['id']) && !empty($l['email']) && empty($l['email_id'])) {
    $sql = "
      SELECT id AS email_id FROM civicrm_email WHERE email = '{$l['email']}' AND contact_id = {$l['id']}
    ";
    $result = mysqli_query($nyss_conn, $sql);

    if ($result && $row = mysqli_fetch_assoc($result)) {
      $l['email_id'] = $row['email_id'];
    }

    mysqli_free_result($result);

    unset($sql);
    unset($row);
    unset($result);
  }
} // _findEmail()


function _processCurrentEmployer(&$l, $nyss_conn, $dryrun)
{
  if (array_key_exists('current_employer', $l) && !empty($l['current_employer'])) {
    $sql = sprintf("
      SELECT c.id, c.organization_name
      FROM civicrm_contact c
      WHERE c.organization_name = '%s'
        AND c.contact_type = 'Organization'
        AND is_deleted = 0
      LIMIT 1",
      mysqli_real_escape_string($nyss_conn, $l['current_employer'])
    );
    $result = mysqli_query($nyss_conn, $sql);

    if ($result && $row = mysqli_fetch_assoc($result)) {
      $employerID = $row['id'];
      $employerName = $row['organization_name'];
    }
    else {
      //org was not found with earlier lookup; unsupervised rule is stricter -- no expected return
      //create org contact here and pass ID
      try {
        $employerName = convertProperCase($l['current_employer']);
        $newOrg = civicrm_api3('contact', 'create', [
          'contact_type' => 'Organization',
          'organization_name' => $employerName,
        ]);
        $employerID = $newOrg['id'];
      }
      catch (CiviCRM_API3_Exception $e) {}
    }

    if ($dryrun || empty($employerID)) {
      nyss_out('debug', $employerName.'::'.$employerID, true);
    }
    else {
      //this creates lock wait timeout errors; handle manually
      //CRM_Contact_BAO_Contact_Utils::createCurrentEmployerRelationship($l['id'], $employerID);

      $relTypeId = CRM_Core_DAO::getFieldValue('CRM_Contact_DAO_RelationshipType',
        'Employee of', 'id', 'name_a_b');

      if ($relTypeId) {
        try {
          $relParams = [
            'relationship_type_id' => $relTypeId,
            'contact_id_a' => $l['id'],
            'contact_id_b' => $employerID,
            'is_active' => TRUE,
          ];
          //don't use API; conflicts with transaction wrapper
          //$rel = civicrm_api3('relationship', 'create', $relParams);

          //insert rel
          $sql = sprintf("
            INSERT IGNORE INTO civicrm_relationship
            (relationship_type_id, contact_id_a, contact_id_b, is_active)
            VALUES
            ({$relParams['relationship_type_id']}, {$relParams['contact_id_a']}, {$relParams['contact_id_b']}, {$relParams['is_active']})
          ");
          mysqli_query($nyss_conn, $sql) or die(mysqli_error($nyss_conn));

          //update contact cache
          $sql = sprintf("
            UPDATE civicrm_contact
            SET employer_id = {$employerID}, organization_name = '%s'
            WHERE id = {$l['id']}
          ", mysqli_real_escape_string($nyss_conn, $employerName));
          mysqli_query($nyss_conn, $sql) or die(mysqli_error($nyss_conn));
        }
        catch (CiviCRM_API3_Exception $e) {
          Civi::log()->debug('_processCurrentEmployer', ['e' => $e]);
        }
      }
    }

    mysqli_free_result($result);

    unset($sql);
    unset($row);
    unset($result);
    unset($employerID);
  }
} // _processCurrentEmployer()


function _processNote(&$l, $nyss_conn)
{
  global $dryrun;

  if (array_key_exists('note', $l) && !empty($l['note'])) {
    $params = [
      'entity_table' => 'civicrm_contact',
      'entity_id' => $l['id'],
      'note' => $l['note'],
      'contact_id' => $l['id'],
      'modified_date' => date('Ymd'),
      'subject' => 'Import Note',
      'privacy' => 0,
    ];

    if ($dryrun) {
      nyss_out('debug', $params, true);
    }
    else {
      //don't use API or it conflicts with transaction wrapper
      $sql = sprintf("
        INSERT INTO civicrm_note
        (entity_table, entity_id, note, contact_id, modified_date, subject, privacy)
        VALUES
        ('{$params['entity_table']}', {$params['entity_id']}, '%s', {$params['contact_id']}, '{$params['modified_date']}', '{$params['subject']}', {$params['privacy']})
      ", mysqli_real_escape_string($nyss_conn, $params['note']));
      mysqli_query($nyss_conn, $sql) or die(mysqli_error($nyss_conn));
    }

    unset($params);
  }
} // _processNote()


function _processTags($tagContacts, $type = 'Keywords')
{
  global $dryrun;

  $tag_lookup = [];

  //get parent_id based on tag type
  $parentId = CRM_Core_DAO::singleValueQuery("
    SELECT id
    FROM civicrm_tag
    WHERE name = '{$type}'
      AND parent_id IS NULL
    LIMIT 1
  ");

  if (empty($parentId)) {
    nyss_out('debug', "unable to determine tag parent_id...", true);
    return;
  }

  if (!$dryrun) {
    if (!empty($tagContacts)) {
      //make sure entity_tag table is clean and index exists
      checkTagIndex();

      $tagStart = time();
      //nyss_out('debug', $tagContacts, true);
      //nyss_out('debug', 'keyword_lookup', true);
      //nyss_out('debug', $tag_lookup, true);

      nyss_out('debug', "processing tags...", true);
      foreach ($tagContacts as $tag => $tContacts) {
        if (empty($tag_lookup[$tag])) {
          nyss_out('debug', "looking up {$type}: {$tag}", true);

          $sql = "
            SELECT id
            FROM civicrm_tag
            WHERE name = '{$tag}'
              AND parent_id = $parentId
          ";
          $tagid = CRM_Core_DAO::singleValueQuery($sql);

          if (empty($tagid)) {
            nyss_out('debug', "creating {$type}: {$tag}", true);

            $sql = "
              INSERT INTO civicrm_tag (name, parent_id, is_selectable, used_for, created_id, created_date)
              VALUES ('{$tag}', {$parentId}, 1, 'civicrm_contact,civicrm_activity,civicrm_case', 1, NOW());
            ";
            CRM_Core_DAO::executeQuery($sql);

            $sql = "
              SELECT id
              FROM civicrm_tag
              WHERE parent_id = $parentId
                AND name = '{$tag}';
            ";
            $tagid = CRM_Core_DAO::singleValueQuery($sql);

            //$tagid = $tag['id'];
          }

          $tag_lookup[$tag] = $tagid;
        }
        else {
          $tagid = $tag_lookup[$tag];
          nyss_out('debug', "{$type} tag exists: {$tagid}", true);
        }
        //CRM_Core_Error::debug_var('tagid',$tagid);

        //create sql insert; process in batches
        $eTList = [];
        $eTSqlList = '';
        $b = 0; //batch count
        $tagCount = count($tContacts);
        nyss_out('debug', "tagCount: {$tagCount}", true);

        nyss_out('debug', "cycle through contacts to be tagged: {$type} - {$tag}...", true);
        foreach ($tContacts as $i => $cid) {
          $eTList[] = "'civicrm_contact', $cid, $tagid";
          if (($i%BATCHSIZETAG == 0 && $i !== 0) || $i == $tagCount - 1) {

            $entityTagStart = time();

            $eTSql  = 'INSERT IGNORE INTO civicrm_entity_tag (entity_table, entity_id, tag_id) VALUES (';
            $eTSql .= implode('), (', $eTList);
            $eTSql .= ');';
            CRM_Core_DAO::executeQuery($eTSql);

            //free memory
            unset($eTList);
            $eTList = [];

            $entityTagEnd  = time();
            $entityTagDiff = $entityTagEnd - $entityTagStart;

            nyss_out('debug', "{$type} tag: $tag | set: $b | record: $i | processing time: $entityTagDiff secs.", true);
            $b++;
          }
        }
      }
      $tagEnd = time();
      $tagDiff = $tagEnd - $tagStart;
      nyss_out('debug', "tag processing time: $tagDiff secs.", true);

      unset($tagContacts);
    }
  }
  else {
    nyss_out('debug', "tags to be processed...", true);
    nyss_out('debug', $tagContacts, true);
  }
} // _processTags()


function _processGroup($form_state, $imported_contacts, $new_contacts, $dryrun)
{
  if (!empty($form_state['values']['addtogroup']) &&
    $form_state['values']['addtogroup_handling'] != 'none'
  ) {
    nyss_out('debug', "processing group...", true);

    //retrieve group if exists
    $groupID = '';
    $groupName = $form_state['values']['addtogroup'];
    $params = ['title' => $groupName, 'sequential' => 1, 'options' => ['limit' => 1]];
    $group = civicrm_api3('group', 'get', $params);
    //CRM_Core_Error::debug_var('get group',$group);

    if (empty($group['id'])) {
      if (!$dryrun) {
        $params = [
          'title' => $groupName,
          'is_active' => 1,
        ];
        $groupNew = civicrm_api3('group', 'create', $params);
        $groupID  = $groupNew['id'];
        nyss_out('status', "The {$groupName} group did not exist; it was created during import.", true);
      }
      else {
        nyss_out('status', "The {$groupName} group does not exist; it will be created during import.", true);
      }
    }
    else {
      $groupID = $group['id'];
    }

    //now prepare array for adding contacts to group
    $params = ['group_id' => $groupID];

    //construct the list of contacts to add
    switch ($form_state['values']['addtogroup_handling']) {
      case 'all' :
        $groupContacts = $imported_contacts;
        break;
      case 'new' :
        $groupContacts = $new_contacts;
        break;
      default:
        $groupContacts = '';
        break;
    }

    foreach ($groupContacts as $i => $contact_id) {
      if ($i == 0)
        $params['contact_id'] = $contact_id;
      else
        $params["contact_id.$i"] = $contact_id;
    }
    //CRM_Core_Error::debug_var('create group_contact params',$params);

    if (!$dryrun) {
      $gc = civicrm_api3('group_contact', 'create', $params);
    }

    $groupContactsCount = count($groupContacts);
    nyss_out('status', "Adding {$groupContactsCount} to the {$groupName} group.", true);
  }
} // _processGroup()


function _processEmailImport($new_contacts, $nyss_conn)
{
  nyss_out('debug', "processing email only group...", true);

  global $dryrun;

  //Create the group if it doesn't already exist
  $emailGroupID = '';
  $params = ['name' => 'Email_Only'];
  $emailGroup = civicrm_api3('group', 'getsingle', $params);

  if ($emailGroup['is_error']) {
    if (!$dryrun) {
      $params = [
        'title' => 'Email Only',
        'is_active' => 1,
        'description' => 'Contacts in this group will be excluded from postal mailings processed through Corporate Woods, and may be exclude from internal exports using the print processing option.'
      ];
      $emailGroup = civicrm_api3('group', 'create', $params);
      nyss_out('status', "The 'Email Only' group did not exist; it was created during import.", true);
    }
    else {
      nyss_out('status',"The 'Email Only' group does not exist; it will be created during import.",true);
    }
  }
  $emailGroupID = $emailGroup['id'];

  //add all the contacts to the email only group
  $params = ['group_id' => $emailGroupID];

  //construct the list of contacts to add to groups
  foreach ($new_contacts as $i => $contact_id) {
    if ($i == 0) {
      $params['contact_id'] = $contact_id;
    }
    else {
      $params["contact_id.$i"] = $contact_id;
    }
  }

  //we also need to set these new contacts to 'do_not_mail'
  $new_contacts_list = (!empty($new_contacts)) ? implode(',', $new_contacts) : 0;
  $setDNM = "UPDATE civicrm_contact SET do_not_mail = 1 WHERE id IN ( $new_contacts_list );";

  if (!$dryrun) {
    //create the GroupContact joins for each of these contacts
    civicrm_api3('group_contact', 'create', $params);

    //set do not mail
    $result = mysqli_query($nyss_conn, $setDNM);
  }

  $newContactsCount = count($new_contacts);

  nyss_out('status', "Adding {$newContactsCount} to the Email Only group", true);

  unset($params);
  unset($new_contacts_list);
  unset($result);
  unset($newContactsCount);
} // _processEmailImport()


function _processAddressDelete($addressDel, $nyss_conn, $dryrun)
{
  if (!empty($addressDel) && !$dryrun) {
    nyss_out('debug', "processing addresses to be trashed...", true);
    $addressDelList = implode(',', $addressDel);
    $sqlAD = "
      DELETE FROM civicrm_address
      WHERE id IN ( $addressDelList );
    ";
    $result = mysqli_query($nyss_conn, $sqlAD);

    unset($result);
    unset($sqlAD);
    unset($addressDelList);
  }
} // _processAddressDelete()


function _cleanData(&$l)
{
  foreach ($l as $k => &$v) {
    if (is_string($v)) {
      $v = CRM_Utils_String::stripSpaces($v);
      $v = CRM_Utils_Type::escape($v, 'String');
    }
  }
} // _cleanData()

/**
 * @param $l
 *
 * @return bool
 *
 * simple helper to determine if an address already exists for this contact.
 * used to determine if we should set new address block as primary.
 */
function _addressExists($l) {
  if (!empty($l['contact_id'])) {
    $sql = "SELECT id FROM civicrm_address WHERE contact_id = {$l['contact_id']} LIMIT 1";
    if (CRM_Core_DAO::singleValueQuery($sql)) {
      return TRUE;
    }
  }

  return FALSE;
}
